# Interrupts

Interrupts are signals emitted by hardware or software when a process or an event needs immediate attention. It alerts the processor to a high-priority process requiring interruption of the current working process. Interrupts are commonly used by hardware devices to indicate electronic or physical state changes that require time-sensitive attention. Interrupts are also commonly used to implement computer multitasking, especially in real-time computing. Systems that use interrupts in these ways are said to be **interrupt-driven**.

Interrupts can be classified into two types:

- Hardware interrupts
- Software interrupts

Hardware interrupts are generated by internal peripherals within the microcontroller or external devices such as keyboards, mice, printers, etc. They are asynchronous and can occur at any time during program execution. Software interrupts are generated by programs themselves.

## Polling vs Intrrupts

Polling is like a child that keeps nagging.

It is a simple method of checking the status of a device by repeatedly reading the status register of the device. The program keeps checking the status of the device until the device is ready to accept the next instruction. This method is not efficient and wastes a lot of processor time.

Interrupts are like a child that is told to wait until the parent is free.

Interrupts are a method of handling asynchronous events. When an event occurs, the processor is interrupted and the program is suspended. The processor then executes an interrupt service routine (ISR) to handle the event. The processor then returns to the program that was interrupted.

## Interrupt Service Routine (ISR)

For every interrupt, there must be an interrupt service routine (ISR), or interrupt handler. When an interrupt occurs, the microcontroller runs the interrupt service routine. For every interrupt, there is a fixed location in memory that holds the address of its interrupt service routine, ISR. The table of memory locations set aside to hold the addresses of ISRs is called as **the Interrupt Vector Table**.

## Interrupt Vector Table

The Interrupt Vector Table is a table of memory locations that hold the addresses of the interrupt service routines.

In the ATMEGA328, the Interrupt Vector Table is located at the beginning of the program memory. The Interrupt Vector Table is 32 bytes long. Each entry in the Interrupt Vector Table is 2 bytes long.

## How Interrupts are executed

When an interrupt occurs, the microcontroller does the following:

1. Saves the current program counter (PC) to the stack.
2. Saves the current status register (SREG) to the stack.
3. Loads the address of the ISR from the Interrupt Vector Table.
4. Jumps to the ISR.
5. Upon executing the RETI instruction, the microcontroller does the following:
   1. Restores the SREG from the stack.
   2. Restores the PC from the stack.
   3. Continues executing the program.

## Intrrupt Modes

Interrupts can be classified into two types:

- **Level-triggered interrupts** - The interrupt is triggered when the signal is high.
- **Edge-triggered interrupts** - The interrupt is triggered when the signal changes from low to high or high to low.

## Interrupt Priorities

Interrupts can be classified into two types:

- **Non-maskable interrupts** - These interrupts cannot be disabled. They are used for critical events such as power failure.
- **Maskable interrupts** - These interrupts can be disabled. They are used for non-critical events such as keyboard input.

### Non-maskable interrupts in AVR

The non-maskable interrupts in AVR are:

- External Reset
- Brown-out Reset
- Watchdog Reset

### Maskable interrupts in AVR

The maskable interrupts in AVR are:

- External Interrupts
- Timer/Counter Interrupts
- USART, SPI, and TWI Interrupts

## Interrupts in AVR

### Enabling Interrupts

To enable interrupts, the global interrupt flag, I, in the status register, SREG, must be set. This is done by executing the `sei()` instruction.

### Disabling Interrupts

To disable interrupts, the global interrupt flag, I, in the status register, SREG, must be cleared. This is done by executing the `cli()` instruction.

### Interrupts in AVR

### External Interrupts

External interrupts are interrupts generated by external devices such as keyboards, mice, printers, etc. External interrupts are asynchronous and can occur at any time during program execution.

**The external interrupts in AVR are**:

- INT0
- INT1

**Example**:

```c
#include <avr/io.h>
#include <avr/interrupt.h>

int main(void)
{
    DDRB |= (1 << PB5); // Set PB5 as output
    PORTB |= (1 << PB5); // Set PB5 high

    DDRD &= ~(1 << PD2); // Set PD2 as input
    PORTD |= (1 << PD2); // Enable pull-up resistor on PD2

    EICRA |= (1 << ISC01); // Trigger INT0 on falling edge
    EIMSK |= (1 << INT0); // Enable INT0

    sei(); // Enable interrupts

    while (1)
    {
        // app logic
    }
}

ISR(INT0_vect)
{
    PORTB ^= (1 << PB5); // Toggle PB5
}
```

### Timer/Counter Interrupts

Timer/Counter interrupts are interrupts generated by the Timer/Counter peripherals. Timer/Counter interrupts are asynchronous and can occur at any time during program execution.

**The Timer/Counter interrupts in AVR are**:

- Timer/Counter0 Overflow Interrupt
- Timer/Counter1 Overflow Interrupt
- Timer/Counter2 Overflow Interrupt

**Example:**

```c
#include <avr/io.h>
#include <avr/interrupt.h>

int main(void)
{
    DDRB |= (1 << PB5); // Set PB5 as output
    PORTB |= (1 << PB5); // Set PB5 high

    TCCR0B |= (1 << CS02) | (1 << CS00); // Set prescaler to 1024
    TIMSK0 |= (1 << TOIE0); // Enable Timer/Counter0 Overflow Interrupt

    sei(); // Enable interrupts

    while (1)
    {
        // app logic
    }
}

ISR(TIMER0_OVF_vect)
{
    PORTB ^= (1 << PB5); // Toggle PB5
}
```
